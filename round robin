#include <stdio.h>

#define MAX_PROCESSES 100  

typedef struct {
    int pid;            
    int arrivalTime;    
    int burstTime;      
    int remainingTime;   
    int completionTime;  
    int waitingTime;     
    int turnAroundTime;  
} Process;

void calculateTimes(Process processes[], int n, int timeQuantum) {
    int currentTime = 0, completed = 0;
    int queue[MAX_PROCESSES];           // Queue to manage the processes
    int front = 0, rear = 0;             // Queue pointers
    int inQueue[MAX_PROCESSES] = {0};    // Track if a process is in the queue

    // Add processes to queue based on their arrival time
    while (completed < n) {
        // Enqueue processes that have arrived and are not in the queue
        for (int i = 0; i < n; i++) {
            if (processes[i].arrivalTime <= currentTime && processes[i].remainingTime > 0 && !inQueue[i]) {
                queue[rear] = i;
                rear = (rear + 1) % MAX_PROCESSES;
                inQueue[i] = 1;
            }
        }

        // Check if the queue is empty
        if (front == rear) {
            currentTime++;
            continue;
        }

        // Dequeue the next process
        int idx = queue[front];
        front = (front + 1) % MAX_PROCESSES;
        inQueue[idx] = 0;

        // Execute the process for the time quantum or until completion
        int executionTime = (processes[idx].remainingTime > timeQuantum) ? timeQuantum : processes[idx].remainingTime;
        processes[idx].remainingTime -= executionTime;
        currentTime += executionTime;

        // If process is completed
        if (processes[idx].remainingTime == 0) {
            processes[idx].completionTime = currentTime;
            processes[idx].turnAroundTime = processes[idx].completionTime - processes[idx].arrivalTime;
            processes[idx].waitingTime = processes[idx].turnAroundTime - processes[idx].burstTime;
            completed++;
        }

        // Re-enqueue process if it is not yet completed
        if (processes[idx].remainingTime > 0) {
            queue[rear] = idx;
            rear = (rear + 1) % MAX_PROCESSES;
            inQueue[idx] = 1;
        }
    }
}

void printProcessInfo(Process processes[], int n) {
    float totalWaitingTime = 0, totalTurnAroundTime = 0;

    printf("\nProcess ID\tArrival Time\tBurst Time\tCompletion Time\tWaiting Time\tTurnaround Time\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d\n", processes[i].pid, processes[i].arrivalTime,
               processes[i].burstTime, processes[i].completionTime, processes[i].waitingTime,
               processes[i].turnAroundTime);
        totalWaitingTime += processes[i].waitingTime;
        totalTurnAroundTime += processes[i].turnAroundTime;
    }

    printf("\nAverage Waiting Time: %.2f\n", totalWaitingTime / n);
    printf("Average Turnaround Time: %.2f\n", totalTurnAroundTime / n);
}

int main() {
    int n, timeQuantum;
    Process processes[MAX_PROCESSES];

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    if (n > MAX_PROCESSES) {
        printf("Number of processes exceeds the maximum allowed (%d).\n", MAX_PROCESSES);
        return 1;
    }

    printf("Enter the time quantum: ");
    scanf("%d", &timeQuantum);

   
    for (int i = 0; i < n; i++) {
        processes[i].pid = i + 1;
        printf("Enter Arrival Time and Burst Time for Process %d: ", processes[i].pid);
        scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
        processes[i].remainingTime = processes[i].burstTime;  // Set initial remaining time
    }

    calculateTimes(processes, n, timeQuantum);
    printProcessInfo(processes, n);

    return 0;
}
